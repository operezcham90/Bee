#ifndef opencv_abejas_foto_h_
#define opencv_abejas_foto_h_

#include <sys/timeb.h>

#include <iostream>
#include <fstream>
#include <string>
#include <vector>

//Librerias OPENCV
#include "cv.h"
#include "highgui.h"

using namespace std;


#define PI 3.141592654
#define BITS_PER_BYTE 8
#define UINTSIZE (BITS_PER_BYTE*sizeof(unsigned))
#define EPSILON  1e-6
#define MAXVECSIZE 30
#define MAXPOPSIZE 5000
#define MAXCONSTR  10
#define TRUE 1
#define FALSE 0
#define square(x)  ((x)*(x))

struct indiv
{
	double xreal[3];   // real-coded variables 
	double obj; 			 // objective fn. 
	double u1, v1;			 // coordinates of projection in left image
	double u2, v2;         // coordinates of projection in right image
	int type;           // generated by: 1. mutation.   0. random   -1. cross
	int nicho;
	int state;
};

typedef struct indiv INDIVIDUAL ;
typedef INDIVIDUAL *POPULATION ;        /* array of individuals */

/*===========================================================
Bee Machine*/

class Machine
{
	// The name of the states
	std::string states[6];
	// Transition function
	int delta[12];
	// Counter
	int omega[6];
	// Check if a state exists
	int validateState(int state)
	{
		if (state >= 0 && state <= 5) return 1;
		else return 0;
	}
public:
	Machine(void)
	{
		states [0] = "inactivity (q0)";
		states [1] = "exploration (q1)";
		states [2] = "foraging (q2)";
		states [3] = "recruitment (q3)";
		states [4] = "successful exploration (q4)";
		states [5] = "successful foraging (q5)";
		delta[0] = 1;
		delta[1] = 2;
		delta[2] = 0;
		delta[3] = 4;
		delta[4] = 0;
		delta[5] = 5;
		delta[6] = 0;
		delta[7] = 2;
		delta[8] = 0;
		delta[9] = 3;
		delta[10] = 0;
		delta[11] = 3;
		for (int i = 0; i < 6; i++) {
			omega[i] = 0;
		}
	}
	void addBee()
	{
		omega[0]++;
	}
	int countBeesInState(int state)
	{
		if (validateState(state)) return omega[state];
		else return -1;
	}
	int giveFeedback(int state, int feedback)
	{
		int nextState = -1;
		if (validateState(state))
		{
			if (feedback == 0) //negative feedback
				nextState = delta[state * 2];
			else //positive feedback
				nextState = delta[state * 2 + 1];
			if (omega[state] > 0)
			{
				omega[state]--;
				omega[nextState]++;
				return nextState;
			}
			else return -1; //failure: no bees
		}
		else return -1; //failure: wrong state
	}
	std::string getStateName(int state)
	{
		if (validateState(state)) return states[state];
		else return "";
	}
};

/*===========================================================
GLOBAL VARIABLES  :                                                                                 */

string archivos[4], parametros;
int     pop_size, pop_size_off,       /* Population Size: parents, offspring                  */
   pop_size_for,                 /* Foragers Population Size: parents, */
   mut_type,                      /* 1 if polynomial mut. be used  0 if Normal mut.*/
   cross_type,                      /* 1 if SBX cross. be used  0 if Barycentric cross.*/
   grad,                      /* 1 if gradient is sobel, 0 if not */
  gen_no,                 /* Current generation number            */
  max_gen,                /* Maximum no. of generations           */
  no_xover,               /* No. of cross overs done              */
   no_mutation,binmut,            /* No. of mutations done                */
  best_ever_gen,          /* Generation no. of best ever indiv.   */
  nvar_bin,                /* Number of total design variables     */
  nvar_real,
  lchrom,                 /* Length of chromosome                 */
  chromsize,              /* Number of bytes needed to store    lchrom strings          */
  maxrun,                 /* Maxm no. of GA runs for each set of   parameter values          */
  run,                    /* Actual run no.                       */
  SHARING3D, SHARING2D,          /* Flag for Sharing ( True / False)     */
  REPORT,                 /* Flag for Full reports (True/False)   */
  RIGID,                  /* Flag for rigid boundaries (T/F)      */
  tourneylist[MAXPOPSIZE],/* List of indices of individuals for  tournament selection routine    */
  tourneypos,             /* Current position of tournament       */
  tourneysize,            /* Tournament size ( = 2 for binary )   */
  MINM,                    /*var para el proc de seleccion 1-min.  -1 - max*/
  nc,                     /* Number of constraints */
  corre,                /* 1 if correlation is ZNCC; 0 if correlation is SSD*/
  critical_size,          /* subpopulation size used in fTS (0.25*N)  */
 num_abejas,     /* Bees to be printed */
 tipo_matriz;   /*  Projection matrix using Faugeras-Toscani (0) or Louchet-Boumaza (1)*/

int chr_len[MAXVECSIZE];   /* chrom length for each variable */

double   seed,                   /* Random seed number                   */
  basic_seed,             /* Basic seed number                    */
  n_distribution_c,     /* valor de eta, para obtener beta, en el SBX */
  n_distribution_m,
  p_xover,                /* Cross over probability               */
  p_mutation_bin,p_mutation_real, /* Mutation probability                 */
  sum_obj,                /* Sum of objective fn. values          */
  avg_obj,                /* Average of objective fn. values      */
  max_obj,                /* Maximum objective fn. value          */
  min_obj,                /* Minimum objective fn. value          */
  minx_bin[MAXVECSIZE],       /* Minimum and maximum values of design */
  maxx_bin[MAXVECSIZE],       /*        variables in a population     */
  minx_real[MAXVECSIZE],       /* Minimum and maximum values of design */
  maxx_real[MAXVECSIZE],       /*        variables in a population     */
  xbin_lower[MAXVECSIZE],    /* Lower and Upper bounds on each       */
  xbin_upper[MAXVECSIZE],    /*        design variable               */
  xreal_lower[MAXVECSIZE],    /* Lower and Upper bounds on each       */
  xreal_upper[MAXVECSIZE],    /*        design variable               */
  xreal_lower_orig[MAXVECSIZE],    /* backup for Lower and Upper bounds on each       */
  xreal_upper_orig[MAXVECSIZE],    /*        design variable               */
  sigma[MAXVECSIZE],       /*        sigma for normal dist. mutation          */
  sigma_share = 0,            /* Sharing distance                     */
  alpha_share = 0,           /* parameter alpha for 2D sharing */
  rate_cross, rate_mut, rate_rand,   //porcion de la poblacion que lleva a cabo crossover o mutacion o aleatoria
  rate_cross_rec, rate_mut_rec, rate_rand_rec,   //porcion de la poblacion que lleva a cabo crossover o mutacion o aleatoria en recolectoras
  sum_fitness = 0,                 // guarda la suma de fitness
  numero_cross, numero_mut, numero_otros, /*number of succesful individuals by generation*/
  traslacion;    /* traslation between images, in Louchet-Boumaza's projection matrix */
        
POPULATION oldpop, newpop, tempop, nextpop;        /* Old, New Temporal and Next-frame populations              */
INDIVIDUAL best_ever,current_best;           /* Best fit individual till current gen.*/


class opencv_abejas
{
public:
	static void proyecta(int, int = 1);
	static void filtrado(IplImage *, IplImage *, IplImage *, IplImage *);
	static void imprime_abejas();
	static void guarda_exploradoras(); 
	static void set_framerate(int, int);
	static void check_device(int *, char*);
/*EVOLUTIONARY ALGORITHM */
   static int input_param_file(string);
   static void initialize(int, int, IplImage *, IplImage *);
   static void nomemory(const char *string);
   static void error_ptr_null(const char *string);
   static void copy_individual(INDIVIDUAL *indiv1, INDIVIDUAL *indiv2);
   static void generate_new_pop();
   static void create_children(double p1, double p2, double *c1, double *c2, double low, double high, double *rand_var);
   static void cross_over(int first, int second, int childno1, int childno2);
   static double get_beta(double u);
   static double get_delta(double u, double delta_l, double delta_u);
   static void mutation(INDIVIDUAL  *indiv);
   static void free_all();
   static void sharing3D();
   static void sharing2D();
   static void sharing3D_semillas();
   static double sh(int, int);
   static void sh(CvRect);
   static void select_memory();
   static void preselect_tour();
   static int tour_select();
   static double distanc(int one, int two, int = 1);
   static void reset1();
   // OBJETIVO
   static void function_main(string, string, string);
   static void merge_pop();
   static void best_mu();
   static void fitness_function_exp(INDIVIDUAL *, int, int, IplImage *, IplImage *);
   static void fitness_function_rec(INDIVIDUAL *, int, int, IplImage *, IplImage *);   
   static double correlacionZNCC(int, int, int, int, IplImage *, IplImage *, int, int);
   static void verifica_pop();
   static void asigna_recolectoras();
};

#endif 

